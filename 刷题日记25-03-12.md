---
title: 刷题日记25-03-12
date: 2025-03-12
categories: [题解,acm]
excerpt: 博主2025-03-12的刷题日记
problems:
  - id: "43"
    name: "abc390_D"
    tags: ["搜索", "剪枝", "思维", "绿"]
  - id: "44"
    name: "abc390_E"
    tags: ["dp", "背包", "01背包", "黄"]
  - id: "45"
    name: "abc390_F"
    tags: ["思维", "区间", "dp", "容斥原理", "绿"]
  - id: "46"
    name: "abc389_E"
    tags: ["思维", "二分答案", "整体二分", "贪心", "蓝"]
  - id: "47"
    name: "abc389_F"
    tags: ["思维", "二分答案", "数据结构", "树状数组", "线段树", "蓝"]
  - id: "48"
    name: "CF1008div2_C"
    tags: ["思维", "构造", "排序", "黄"]
  - id: "49"
    name: "CF1008div2_D"
    tags: ["思维", "贪心", "绿"]
---
今天刷了很久题，准备复习线段树

# abc390

## abc390_D

搜索，剪枝，思维（绿）

**题意：**
有编号为袋 $1$, 袋 $2$, $\ldots$, 袋 $N$ 的 $N$ 个袋子。 
袋 $i$ $(1 \leq i \leq N)$ 中包含 $A_i$ 个石子。

高桥君可以重复以下操作任意次数（包括 $0$ 次）：

> 选择两个袋 A 和 B，将袋 A 中的 **所有** 石子转移到袋 B 中。

请计算操作结束后，以下值可能的不同取值数量：

- 设袋 $i$ 中的石子数量为 $B_i$，计算 $B_1 \oplus B_2 \oplus \cdots \oplus B_N$ 的值。  

**思路：**

- 观察到N<=12，考虑暴力搜索，剪枝
- 问题转化为把 n 个数字填充到 n 个袋子中，求最后的异或和数量
- 对于每个数字i，只讨论1-i的袋子，因为填充是任意的，减少讨论数量
- 还有一点，对于每个数字i，限制为只可以填充第一个空袋子，因为空袋子都是等价的，这样可以剪枝
- 如此暴力搜索，用unordered_map存放最后的异或和，否则可能会超时

```cpp
unordered_map<int, int> mp;
function<void(int, int)> dfs = [&](int x, int m) { // m表示已经分配过的袋子数量
    if (x == n + 1)
    {
        int now = 0;
        for (int i = 1; i <= m; i++) now ^= b[i];
        if (!mp.count(now))
        {
            mp[now] = 1;
            ans++;
        }
        return;
    }

    for (int i = 1; i <= m; i++)
    {
        b[i] += a[x];  // 注意这里加的东西是什么...
        dfs(x + 1, m); // 已经填充的袋子数量不变，不需要讨论更多的空间，算是剪枝
        b[i] -= a[x];
    }
    b[m + 1] = a[x]; // 每次只往后拓展一个位置，减少讨论数量
    dfs(x + 1, m + 1);
};
```



## abc390_E

dp，背包，01背包（黄）

**题意：**

有 $N$ 种食物，每种食物恰好含有维生素 $1$、$2$、$3$ 中的一种。  
具体来说，吃第 $i$ 种食物时，可以摄取维生素 $V_i$ 的量为 $A_i$，同时摄入卡路里 $C_i$。

高桥君可以选择吃其中的若干种食物（包括 $0$ 种），使得总摄入卡路里不超过 $X$。  
请计算在此条件下，「维生素 $1$、$2$、$3$ 中摄入量最少的那种维生素的摄入量」可能达到的最大值。

**思路：**

- 对于每一种维他命，单独计算消耗，由此进行01背包

- 01背包可以优化掉第一维的dp数组，原理是从后往前继承更新不会对这一轮造成额外影响

- 最后枚举每个种类的维他命占据的消耗，枚举$O(n^2)$即可，取其中三者最小值的最大值
- 主要是需要想到**单独计算每种的消耗，最后枚举消耗的分配**

```cpp
for (int i = 1; i <= n; i++)
{
    auto [v, a, c] = p[i];
    for (int j = x - c; j >= 0; j--) // 普通01背包，可以优化掉第一维
    {
        dp[j + c][v] = max(dp[j + c][v], dp[j][v] + a);
    }
}
int ans = 0;
for (int i = 0; i <= x; i++)
{
    for (int j = 0; i + j <= x; j++)
    {
        int k = x - i - j;
        int now = min(dp[i][0], min(dp[j][1], dp[k][2]));
        ans = max(ans, now);
    }
}
cout << ans << '\n';
```



## abc390_F

思维，区间，dp，容斥原理（绿）

**题意：**

给定一个长度为 $N$ 的整数序列 $A = (A_1, A_2, \ldots, A_N)$。

对于满足 $1 \leq L \leq R \leq N$ 的整数对 $(L, R)$，定义 $f(L, R)$ 如下：

- 初始时，在黑板上按顺序写下 $R-L+1$ 个整数 $A_L, A_{L+1}, \ldots, A_R$。
- 重复以下操作直到黑板上所有整数被清除：
  - 选择两个整数 $l, r$，需满足 $l \leq r$ 且黑板上当前存在的所有 $[l, r]$ 范围内的整数至少各出现一次。随后清除黑板上所有 $[l, r]$ 范围内的整数。
- $f(L, R)$ 定义为清除所有整数所需的最小操作次数。

请计算 $\displaystyle \sum_{L=1}^N \sum_{R=L}^N f(L, R)$ 的值。

**思路：**

- 正面枚举每个区间的连续整数数量肯定不行。根据过往经验，我们想到可以逆向来看，计算每个连续整数的片段对于所有区间的贡献。
- 因为$n^2$个区间都必须被计算到，所以我们取连续整数片段是比较自由的，关键在于不重不漏
- 考虑对于每个$a_i$，求以$a_i$结尾的整数片段所在的区间的数量。我们向左找到第一个$a_i$或者$a_{i+1}$的位置pre，向右找到第一个$a_{i+1}$的位置nxt，则所有$l,r,l \in [pre+1,i],r \in [i,pre-1]$构成的片段$[l,r]$都是以$a_i$结尾的整数片段所在的区间，也就计算为一个贡献值
- 于是乎先预处理出nxt和pre数组，再对于每个数字计算即可，时间复杂度是$O(n)$

```cpp
for (int i = 1; i <= n; i++)
{
    pre[i] = max(pos[a[i]], pos[a[i] + 1]);
    pos[a[i]] = i;
}

fill(all(pos), n + 1); // 如果不存在，则到最远n+1的右端点构成的区间都可以作为贡献区间
for (int i = n; i >= 1; i--)
{
    nxt[i] = pos[a[i] + 1];
    pos[a[i]] = i;
}
int ans = 0;
for (int i = 1; i <= n; i++)
{
    ans += (nxt[i] - i) * (i - pre[i]);
}
cout << ans << '\n';
```

值得注意的是，非常精妙的，nxt和pre的构造并不对称。可以从左侧取到右侧的相同数字，但是不能从右侧取到左侧的。这样恰好不重不漏，如果nxt[i] = min(pos[a[i] + 1], pos[a[i]]);就错误了。因为我们需要取到相同的数字，但是只能计算一次贡献



# abc389

## abc389_E

思维，二分答案，整体二分，贪心（蓝）

**题意：**

有 $ N $ 种商品，每种商品各有 $ 10^{100} $ 个。

你可以购买任意数量的每种商品（包括 0 个）。购买第 $ i $ 种商品 $ k $ 个需要花费 $ k^2 P_i $ 日元。

在总花费不超过 $ M $ 日元的条件下，求最多可以购买多少个商品。

**思路：**

- 乍一看很像无限背包，但实际上完全不同。每个商品的价格都不同，由平方差求得，每个物品价格为$(2k-1) \times p_i$，且之前必须要购买 k-1 个这个种类的商品
- 一开始想到直接用小根堆模拟贪心，每次买最便宜的商品。但是超时
- 考虑到最大购买的价格会有一个上限，知道了上限之后就可以用$O(1)$贪心地购买每个种类中价格小于等于上限的商品
- 于是对于最大购买价格整体二分。check函数是看购买了每类低于当前价格的所有商品之后，是否超出预算
- 最后把剩余预算全部花掉

```cpp
int l = 0, r = m; // 二分的是购买的最贵的商品价格
auto chk = [&](int x)
{
    int cnt = 0;
    for (int i = 1; i <= n; i++)
    {
        int k = (x + a[i]) / (2 * a[i]); // 算出当前上限，当前商品的最大购买量
        if (k > 1e9 || a[i] > 2e18 / (k * k))
            return 0;
        int now = k * k * a[i]; // 可以直接算出当前商品的总价格
        if (now + cnt > m)      // 看是否超过了预算
            return 0;
        cnt += now;
    }
    return 1;
};

while (l + 1 < r)
{
    int m = (l + r) / 2;
    if (chk(m))
        l = m;
    else
        r = m;
}
int ans = 0;
for (int i = 1; i <= n; i++)
{
    int now = (l + a[i]) / (2 * a[i]);
    m -= now * now * a[i]; // now表示最大的k
    ans += now;
}
ans += m / (l + 1); // 剩下的用来尝试购买价格为k+1的商品
// 根据二分，可以买完价格在 l 及以下的所有物品，而 l+1 不能，有多的物品买不起，而不会出现买完了的情况
```



## abc389_F

思维，二分答案，数据结构，树状数组，线段树（蓝）

**题意：**

高桥君计划参加 AtCoder 的 $ N $ 场竞赛。

在第 $ i $ 场竞赛（$ 1 \leq i \leq N $）中，若他的评分处于 $ L_i $ 到 $ R_i $ 的闭区间内，则评分会增加 $ 1 $ 分。

请回答以下形式的 $ Q $ 个查询：

- 给定整数 $ X $，假设高桥君的初始评分为 $ X $，求经过所有 $ N $ 场竞赛后的最终评分。

**思路：**

这里给出洛谷题解中看到的树状数组方法（最简洁）

- 这个问题有以下性质：
  - 评分单调不减
  - 两个初始评分变化过程中不会交叉
  - 每个竞赛区间，都对应一个连续的初始区间，只有初始在这个区间中才会经过这个竞赛区间
- 这个题解利用性质3解决了问题
- 顺序处理每个竞赛区间$[L_i,R_i]$，我们可以维护一个数组arr，表示经过之前的区间1 - i-1，初始评分为 x 的位置获得了的加分（也就是通过了的竞赛区间）
- 可以用树状数组维护这个 arr 数组的差分数组 dif ，支持区间修改，单点查询
- 每次计算当前的$[L_i,R_i]$对应的初始区间$[l_i,r_i]$,然后通过树状数组修改 dif
- 那么如何计算$[L_i,R_i]$对应的初始区间$[l_i,r_i]$呢？因为$l_i$一定是可以到达的最小初始评分，$r_i$是可以到达的最大评分，可以利用这个性质二分答案。
- 也就是利用之前的 dif 数组(表示1 ~ i-1)，计算某个初始评分是否可达。详见代码。
- 然后对于每个查询，直接通过树状数组的单点查询解决即可

以下是树状数组：

```cpp
namespace BIT
{
    int tr[N];

    void update(int p, int k)
    {
        for (; p < N; p += (p & -p)) tr[p] += k;
    }

    int query(int p)
    {
        int res = 0;
        for (; p; p -= (p & -p)) res += tr[p]; // 也就是算出前缀和
        return res;
    }
}
```

以下是二分的部分

```cpp
for (int i = 1; i <= n; i++)
    {
        cin >> L[i] >> R[i];
        
        // 二分查找 l_i: 初始评分 X 的最小值，使得 X + sum_X >= L[i]
        int left = 1, right = L[i], l_i = 1; // l_i: 当前竞赛的左边界
        while (left <= right)
        {
            int mid = left + right >> 1; 
            if (mid + query(mid) >= L[i])
            {                    // 若 mid 加分后达到或超过 L[i]
                l_i = mid;       
                right = mid - 1; // 尝试更小的 mid
            }
            else
            {
                left = mid + 1; // mid 太小，增大范围
            }
        }

        // 二分查找 r_i: 初始评分 X 的最大值，使得 X + sum_X <= R[i]
        int r_i;                        
        left = 1, right = R[i], r_i = 1; // r_i: 当前竞赛的右边界
        while (left <= right)
        {
            int mid = left + right >> 1; 
            if (mid + query(mid) <= R[i])
            {                   // mid 加分后不超过 R[i]
                r_i = mid;      
                left = mid + 1; // 尝试更大的 mid
            }
            else
            {
                right = mid - 1; // mid 太大，减小范围
            }
        }

        update(l_i, 1);     
        update(r_i + 1, -1); // 更新差分数组
    }
```



# CF1008div2

前天赛时打的，艰难想出了C（机房已经对过答案了，但我没听见），一起卡在了D

## CF1008div2_C

思维，构造，排序（黄）

**题意：**

给出序列 $a_1,a_2 \ldots a_{2n+1}$:

- $1 \le a_i \le 10^{18}$ for all $1 \le i \le 2n + 1$. 
- $a_1, a_2, \ldots, a_{2n+1}$ 成对不同
- $a_1 = a_2 - a_3 + a_4 - a_5 + \ldots + a_{2n} - a_{2n+1}$.

从这个序列中删除了一个数字，并将其余的数字洗牌，给你留下了一个序列 $b_1,b_2 \ldots b_{2n}$ 。你忘记了序列a ，想找到恢复它的方法。

如果有许多可能的序列，那么你可以输出其中任何一个。在问题的限制条件下，可以证明至少有一个序列a 存在。

**思路：**

- a1 显然可以是存在的数字，也可以是不存在的数字

- 我们需要构造出一个被删除的数字（和所有已知数字不同）以及排序方式

- 有三种位置，a1位置（不参与），加数位置，减数位置，后两者数量相等，而最保险的构造方式就是找出一个比存在的最大值更大的数字

- 让被删除的数字 x 占据一个加数位置，让max(a)占据a1位置，那么剩下的减数位置一定多于加数，则有:

  $$a_1 = max(a) = X - \sum_{1}^{2n-1} -1^ka_i$$

- 从小到大排序，使较大的n个数字全在减数位置，其余在加数位置，保证$X > max(a)$

```cpp
void solve()
{
    int n;
    cin >> n;
    vector<int> a(2 * n);
    for (auto &i : a)
        cin >> i;
    sort(a.begin(), a.end());
    int now = 0;
    for (int i = 2 * n - 2; i >= n - 1; i--)
        now += a[i];
    for (int i = n - 2; i >= 0; i--)
        now -= a[i];
    now += a[2 * n - 1];
    cout << a[2 * n - 1] << ' ' << now << ' ';
    int p = 2 * n - 2, q = 0;
    for (int i = 0; i < n - 1; i++)
    {
        cout << a[p] << ' ' << a[q] << ' ';
        p--;
        q++;
    }
    cout << a[n - 1] << '\n';
}
```



## CF1008div2_D

思维，贪心（绿）

**题意：**

一个游戏有n对门需要通过，每对包含一个左门和一个右门

每扇门有两种操作：

- 加法（$+a$）：增加 a 个人。
- 乘法（$\times a$）：将当前人数乘以 a，即增加 (a−1)×当前人数

初始时，左右道各有 1 人。

每次操作产生的新增人数可以分配到任一道路，但已有的人不能移动。目标：通过 n 对门后，最大化左右道路总人数。

**思路：**

赛时一直在想按照后缀的乘数来判断分配方向。实际上不需要，大致上只要贪心地更多分配到当前乘数较大的一侧即可。简单地分类讨论：

- 维护变量ll，rr，now，分别表示当前左道已分配人数，右道已分配人数，新增的自由人数

- 如果两者都是加法，或者都是乘法且乘数相同，视为“均衡”情况，暂时不分配新增的自由人数（从当前来看，分配两侧是等价的）。先悬而未决，把新增的人数都视为自由人，直到遇到第一个“非均衡”的情况，再回溯性地把自由人分配到两个道路。
- 否则视为非均衡。如果两者一个加法一个乘法，全部分到乘法；如果两者都是乘法但乘数不同，贪心地分配到乘数大的一侧。
- 以上，不是dp，不用考虑后缀乘数之积或者和！

```cpp
struct node
{   char a;int b;} l[31], r[31];

void solve()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> l[i].a >> l[i].b >> r[i].a >> r[i].b;
    }
    int ll = 1, rr = 1, now = 0;

    for (int i = 1; i <= n; i++)
    {
        if (l[i].a == '+' && r[i].a == '+')
        {
            now += l[i].b + r[i].b;
        }
        else if (l[i].a == 'x' && r[i].a == 'x' && (l[i].b == r[i].b))
        {
            now += (ll + rr + now) * (l[i].b - 1);
        }

        // 以上是均衡的,只是新增，存放在now中，但是不分配

        else if (l[i].a == 'x' && r[i].a == '+')
        {
            ll += now;
            now = ll * (l[i].b - 1) + r[i].b;
        }
        else if (l[i].a == '+' && r[i].a == 'x')
        {
            rr += now;
            now = rr * (r[i].b - 1) + l[i].b;
        }
        else if (l[i].a == 'x' && r[i].a == 'x' && l[i].b != r[i].b)
        {
            if (l[i].b > r[i].b)
                ll += now;
            else
                rr += now;
            now = ll * (l[i].b - 1) + rr * (r[i].b - 1);
        }
    }
    cout << ll + rr + now << '\n';
}
```



