---
title: 刷题日记25-03-06
date: 2025-03-06
categories: [题解,acm]
excerpt: 博主2025-03-06的刷题日记
problems: 
    - id: "27"
      name: "abc395_D"
      tags: ["并查集", "映射", "思维", "黄"]
    - id: "28"
      name: "abc395_E"
      tags: ["思维", "最短路", "绿"]
    - id: "29"
      name: "abc395_F"
      tags: ["思维", "二分答案", "绿"]
    - id: "30"
      name: "abc394_E"
      tags: ["最短路", "回文串", "绿"]
    - id: "31"
      name: "abc394_F"
      tags: ["树形dp", "排序", "贪心", "绿"]
    - id: "32"
      name: "abc393_D"
      tags: ["三分", "思维", "黄"]
    - id: "33"
      name: "abc393_E"
      tags: ["思维", "gcd", "筛法", "黄"]
    - id: "34"
      name: "abc393_F"
      tags: ["dp", "LIS", "绿"]
    - id: "35"
      name: "abc392_E"
      tags: ["图论", "并查集", "连通分量", "绿"]
    - id: "36"
      name: "abc392_F"
      tags: ["数据结构", "蓝"]
---

# 刷题日记25-03-06
本日居然板刷了四场abc，虽然不少题似乎不经思考就直接看题解了，但是还是有不少收获的。完成最新的四场abc392 - 395（除了最后一题，超出我的能力范围）

# abc395

## abc395_D

并查集，映射，思维（黄）

题意：

有N只鸽子（编号 1 到N）和 N个巢（编号 1 到N），初始时鸽子i在巢i中。进行Q次操作：

- **类型 1**：将鸽子a 从当前巢移到巢b。
- **类型 2**：交换巢 a和巢b中的所有鸽子（同时进行）。
- **类型 3**：报告鸽子a 当前所在的巢编号。

思路：

这里并没有使用并查集，而是通过引入"坐标"的新一层抽象，简化了问题

鸽子移动到巢->鸽子移动到另一个坐标

两个巢穴中的所有鸽子互换位置->两个巢穴交换，鸽子不动，但是鸽子->位置->巢穴的映射改变了

- 不直接追踪每个巢的鸽子列表，而是用3个数组：
  - home[i]：鸽子i所属的巢编号。
  - ed[i]：位置i当前对应的巢编号。
  - st[i]：巢i当前所在的位置。
- 操作：
  - 类型 1：更新 home[i]为目标巢。
  - 类型 2：交换两个巢的位置。
  - 类型 3：通过ed home查询位置。

```cpp
if (op == 1)
{
    int a, b;
    cin >> a >> b;
    home[a] = st[b]; // 分离了鸽子和巢，用坐标连接起来表示
}
else if (op == 2)
{
    int a, b;
    cin >> a >> b;
    ed[st[a]] = b; // 原先巢 a 的坐标现在对应巢 b
    ed[st[b]] = a; // 原先巢 b 的坐标现在对应巢 a
    swap(st[a], st[b]); // 交换巢 a 和巢 b 的坐标位置
}
else
{
    int a;
    cin >> a;
    cout << ed[home[a]] << '\n';
}
```



## abc395_E

思维，最短路（绿）

题意：

给定一个包含 *N* 个顶点和 *M* 条边的有向图。第 *i* 条边（1≤*i*≤*M*）从顶点 *ui* 指向顶点 *vi*。

初始时，你位于顶点 1，需要通过重复以下操作到达顶点 *N*：

- 选择以下两种操作之一：
  - **移动操作**：从当前顶点沿边移动到相邻顶点，成本为 1。具体来说，设当前顶点为 *v*，选择一条从 *v* 指向 *u* 的边，移动到顶点 *u*。
  - **翻转操作**：反转所有边的方向，成本为 *X*。具体来说，在操作前存在的每条从 *v* 到 *u* 的边，在操作后将变为从 *u* 到 *v* 的边，反之亦然。

题目保证存在从顶点 1 到顶点 *N* 的操作序列。

请计算到达顶点 *N* 所需的最小总成本。

思路：

- 把上下翻转视为双层图，即把代价视为两层之间的路径，两层的所有边顺序相反

- 这样建边之后跑dijkstra即可



## abc395_F

思维，二分答案（绿）

题意：

高桥君共有 2*N* 颗牙齿，其中 *N* 颗是上牙，剩余的 *N* 颗是下牙。

左数第 *i* 颗（1≤*i*≤*N*）上牙的长度为 *Ui*，左数第 *i* 颗（1≤*i*≤*N*）下牙的长度为 *Di*。

当高桥君的牙齿满足以下两个条件时，称为「良好咬合」：

1. 存在一个整数 *H*，使得对于所有 1≤*i*≤*N*，有 *Ui*+*Di*=*H*。
2. 对于所有 1≤*i*<*N*，有 ∣*Ui*−*Ui*+1∣≤*X*。

高桥君可以执行以下操作任意次：

- 支付 1 日元使用磨牙工具，选择一个长度为正的牙齿，将其长度减少 1。

除上述操作外，无法通过其他方式改变牙齿长度。请计算高桥君达成良好咬合所需支付的最小金额。

思路：

- 要求最小化金额，也就是最大化所有牙齿最后的上下牙之和H，因此想到二分这个H，关键在于check()函数如何处理

- 关键在于根据两个限制条件找到范围公式：

- 对于一个位置的两颗牙齿，自身的长度只能缩小。因此可以得到上牙自身的范围：

```cpp
int l1 = max(0ll, h - d[i]);
int r1 = min(u[i], h);
```

- 而当前牙齿的长度范围需要和上一颗牙齿的范围扩大之后（贪心，利用绝对值差<=x）的范围取交集

```cpp
int l2 = max(l1, l - x);
int r2 = min(r1, r + x);
```

集合不断更新，需要保持集合存在，否则即为check失败。由此通过二分答案找到最优解。

另外，题解中有On方法，但是很难想到



# abc394

## abc394_E

最短路，回文串（绿）

题意：

给定一个包含 *N* 个顶点的有向图，顶点编号为 1,2,…,*N*。

边的信息由 $N^2$个字符 给出。其中为小写字母$C_{i,j}$或 `-`。

- 当 $C_{i,j}$为小写字母时，存在一条从顶点 *i* 到顶点 *j* 的边，且该边的标签为$C_{i,j}$。
- 当$C_{i,j}$为 `-` 时，不存在从顶点 *i* 到顶点 *j* 的边。

对于所有满足 1≤*i*,*j*≤*N* 的整数对 (*i*,*j*)，请回答以下问题：

- 找出从顶点 *i* 到顶点 *j* 的路径（不要求是简单路径），使得路径上边标签按顺序组成的字符串是回文。在所有满足条件的路径中，输出最短路径的长度。若不存在这样的路径，输出 −1。

思路：

回文串两侧扩展相同字符之后仍然是回文串，利用这个属性，进行类似最短路和floyd的递推。而基准点是：空串和单字符都视为回文串

**回文性质**：

- 空串是回文（长度 0）。
- 单字符是回文（长度 1）。
- 若S是回文，在首尾添加相同字符仍是回文。

**算法设计**：

- 用 ans(i,j)表示从i到j的最短回文路径长度。
- 初始：
  - i == j：长度 = 0（空路径）。
  - $C[i][j] \neq '-'$且$i \neq j$：长度 = 1（单边）。
- 扩展：若ans(i,j)已知，且存在边k->i和j->l，且满足这两条边相同，则k->l的路径也是回文，长度为ans(i,j) + 2

**BFS**：

- 用队列存储已知的回文路径点对，逐步扩展。

```cpp
// 初始化，所有点对的最短回文路径长度为无穷大
memset(ans, 0x3f, sizeof(ans));

// 处理基础情况1：同一点到自身，路径长度为0（空串是回文）
for (int i = 1; i <= n; i++)
    ans[i][i] = 0, q.push({ i, i });

// 处理基础情况2：直接相连的点，路径长度为1（单字符是回文）
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++)
        if (i != j && c[i][j] != '-')
            ans[i][j] = 1, q.push({ i, j });

// BFS扩展，利用回文的构造性质
while (!q.empty())
{
    auto u = q.front();
    q.pop();
    int i = u.first, j = u.second; // 当前已知的回文路径，从i到j

    // 尝试扩展：考虑所有可能的"外层点对"(k,l), 思路类似floyd
    for (int k = 1; k <= n; k++)
        if (c[k][i] != '-') // 存在从k到i的边
            for (int l = 1; l <= n; l++)
                if (c[k][i] == c[j][l]) // 边标签相同，可以构成新回文
                    if (ans[k][l] == INF) // 首次发现从k到l的回文路径
                        ans[k][l] = ans[i][j] + 2, q.push({ k, l }); // 更新路径长度并加入队列
}
```



## abc394_F

树形dp，排序，贪心(绿)

题意：

给定一棵包含 *N* 个顶点的无向树 *T*。顶点编号为 1,2,…,*N*，第 *i* 条边连接顶点 *Ai* 和顶点 *Bi*。

定义满足以下两个条件的图为**烷烃**：

- 该图是一棵无向树
- 所有顶点的度数为 1 或 4，且至少存在一个度数为 4 的顶点

请判断 *T* 中是否存在满足烷烃定义的子图。若存在，求此类子图的顶点数的最大值；否则输出 −1。

思路：

- dp(i,fa) 表示以i为根、fa为父亲的最大子图的结点数量
- 若u是根（无父节点），需要 4 个子树；若u是非根，需要 3 个子树（父节点占一个度）。

- 为什么要管父亲，因为题干说至少有一个度数=4的点，那么这个点一定是根节点。也就是要从根节点开始dp，尝试所有度数>=4的点，对于每个根节点得到的子图大小取最大值。

- 对于每个点计算子树节点数量的时候，贪心取得子节点最多的几个点即可。也就是对当前结点u的子树从大到小排序，取最大的need个作为子树结点数
- 若子树数不足need，dp(u,fa)=1（仅u自身）。

```cpp
void dfs(int u, int fa)
{
    // 记忆化搜索
    if (dp[u][fa] != 0)
        return;

    // 确定需要的子树数：根节点需要4个，非根需要3个
    int need = 3 + (fa == 0);

    // 存储所有子树的dp值
    vector<int> ls;
    for (auto i : a[u])
    {
        if (i != fa) // 不往父节点走
        {
            dfs(i, u);              // 递归处理子树
            ls.push_back(dp[i][u]); // 记录子树的dp值
        }
    }

    // 按dp值从大到小排序，只保留前need大的值
    sort(ls.begin(), ls.end(), greater<int>());
    if ((long long)ls.size() > need)
        ls.resize(need); // 只保留前need个最大值

    // 计算dp值：如果能恰好选need个子树，则累加这些子树的dp值；否则为0
    int sum = 0;
    for (auto i : ls)
        sum += i;

    // 最终dp值 = 子树贡献 + 当前节点(1)
    dp[u][fa] = ((long long)ls.size() == need ? sum : 0) + 1;
}
```



# abc393 

## abc393_D

三分，思维(黄)

三分法可以求解单峰函数最值问题，注意边界。

```cpp
while (r - l >= 3)
{ // 当范围足够大时继续三分
    int m1 = l + (r - l) / 3;
    int m2 = r - (r - l) / 3;
    ll fm1 = func(m1), fm2 = func(m2);
    if (fm1 <= fm2) // 并不直接取相等情况，那样会有问题
    {
        r = m2; // 左半部分可能包含最小值
    }
    else
    {
        l = m1; // 右半部分可能包含最小值
    }
}
// 在缩小后的范围内枚举最小值
ll ans = INF;
for (int i = l; i <= r; i++)
{
    ans = min(ans, func(i));
}
```

有O(n)正解，只需取所有ai=1的坐标的中间点，全部聚拢在中间即可。题解中没有提到三分法



## abc393_E

思维，gcd，筛法（黄）

题意：

给定一个长度为 $ N $ 的数列 $ A=(A_1,A_2,\dots,A_N) $ 和一个不超过 $ N $ 的正整数 $ K $。 
对于每个 $ i=1,2,\dots,N $，请解决以下问题：

- 从 $ A $ 中选出包含 $ A_i $ 的 $ K $ 个元素时，求这些元素的最大公约数 (GCD) 可能达到的最大值。

思路：

- 把gcd转化成从小到大遍历，把当前值更新到自己和所有倍数上（如果倍数数量满足条件）

- 类似筛法，和数的范围高度相关，记录倍数的数量

- 如果当前倍数数量达标，更新所有倍数的ans为当前值，从小到大枚举筛选

如下是核心的循环（n * log(n) * log(n))

```cpp
for (int x = 1; x <= mx; x++){
    int sum = 0;
    for (int j = x; j <= mx; j += x)
    { // 所有倍数的数量之和，范围是数字上限，而不是数组
        sum += vis[j];
    }
    if (sum >= k) 
    // 如果倍数的数量可以达到k，就更新所有的gcd
    {
        for (int j = x; j <= mx; j += x)
        {
            ans[j] = max(ans[j], x);
        }
    }
}
```



## abc393_F

dp，LIS（绿）

题意：

给定一个长度为 $ N $ 的整数序列 $ A=(A_1,A_2,\dots,A_N) $。

请处理 $ Q $ 个查询。第 $ i\ (1 \leq i \leq Q) $ 个查询如下：

- 给定整数 $ R_i $ 和 $ X_i $。求数列 $ (A_1,A_2,\dots,A_{R_i}) $ 的（不一定连续的）子序列中，满足严格单调递增且所有元素不超过 $ X_i $ 的最长长度。保证 $ X_i \geq \min\{ A_1, A_2, \dots, A_{R_i} \} $。

思路：

离线，根据查询的前缀边界排序即可

可以直接在LIS的贪心插入的单调队列中二分查找每个查询的数值限制位置

因为构造单调队列的时候已经贪心取得最小值了，直接二分限制位置已经可以得知可以取得的数量

```cpp
for (int i = 1; i <= n; i++)
{
    auto it = lower_bound(f.begin(), f.end(), a[i]);
    if (it == f.end())
        f.push_back(a[i]);
    else
        *it = a[i];

    while (qi <= q && query[qi].r == i)
    { // 处理恰好卡到这里的查询
        int now = upper_bound(f.begin(), f.end(), query[qi].x) - f.begin() - 1;
        query[qi++].ans = now;
    }
}
```



# abc392

## abc392_E

图论，并查集，连通分量(绿)

题意：

给定N台服务器（编号 1 到N）和M根电缆，每根电缆连接一对服务器ai,bi

- **操作**：选择一根电缆，将其一端连接到另一台服务器（双向连通）。
- **目标**：通过最少操作使所有服务器连通（形成一个连通分量），并输出操作次数和序列。

思路：

- 通过并查集寻找成环的多余边，加入一个多余边的集合

- 找到每个连通分量的根节点，用多余边连接不同的连通分量

关键操作:

```cpp
for (int i = 1; i <= m; i++)
{
    int x, y;
    cin >> x >> y;
    edges[i] = {x, y, i};
    int fx = find(x), fy = find(y);
    if (fx == fy)
    {
        extra.push_back(i); // 记录重边,自环或成环边
    }
    else
    {
        unite(x, y); // 合并连通分量
    }
}
```

实际上想到用并查集就很简单了



## abc392_F

数据结构（蓝）

题意：

初始时有一个空数组 *A*。按 *i*=1,2,…,*N* 的顺序依次执行以下操作：

- 将数字 i 插入 A 的从前数第$p_i$个位置。更准确地说，将 *A* 替换为「*A* 的前$p_{i-1}$个元素」「数字 *i*」「*A* 的第 $p_{i}$个元素及之后的元素」按此顺序连接后的结果。

请输出所有操作完成后最终的数组 *A*。

思路：

从前往后遍历数组，插入当前的第pi个位置，反过来考虑也就是，从后往前遍历数组，插入当前的第pi个空位。因为后插入的数字会该改变先插入的数字的位置，因此先考虑后插入的数字

总的容量是不变的，只需要统计空位的数量和第pi个空位的位置即可。插入之后，需要更新空位数组。

可以通过多种数据结构维护这一问题，这里采取线段树的方法，似乎是最好理解的。底层相当于二分查找目标空位的位置，先找左子树的空位数量，如果大于目标，就递归入左子树找，否则递归入右子树。这里的线段树甚至没有懒标记

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 5e5 + 10; // 最大数组长度

// 线段树结构体
struct SegTree
{
    vector<int> tr; // 线段树数组，记录区间未赋值位置数

    SegTree(int n) : tr(n * 4, 0) {} // 初始化线段树大小

    // 建树：初始化每个位置为未赋值（1）
    void build(int node, int left, int right)
    {
        if (left == right)
        {
            tr[node] = 1; // 叶节点表示单个位置，初始未赋值
            return;
        }
        int mid = (left + right) >> 1;
        build(node << 1, left, mid);                  // 左子树
        build(node << 1 | 1, mid + 1, right);         // 右子树
        tr[node] = tr[node << 1] + tr[node << 1 | 1]; // 更新父节点
    }

    // 单点更新：将位置 x 标记为已赋值
    void update(int node, int left, int right, int x)
    {
        if (left == right)
        {
            tr[node]--; // 未赋值位置数减 1
            return;
        }
        int mid = (left + right) >> 1;
        if (x <= mid)
            update(node << 1, left, mid, x);
        else
            update(node << 1 | 1, mid + 1, right, x);
        tr[node] = tr[node << 1] + tr[node << 1 | 1]; // 更新父节点
    }

    // 查询第 k 个未赋值位置
    int query(int node, int left, int right, int k)
    {
        if (left == right)
            return left; // 找到叶节点
        int mid = (left + right) >> 1;
        if (tr[node << 1] < k) // 左子树未赋值位置不足 k 个
            return query(node << 1 | 1, mid + 1, right, k - tr[node << 1]);
        return query(node << 1, left, mid, k); // 在左子树中查找
    }
};

int main()
{
    ios::sync_with_stdio(false); // 加速输入输出
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n;
    cin >> n;
    vector<int> pos(n + 1); // 插入位置 P_i，从 1 开始
    for (int i = 1; i <= n; i++)
    {
        cin >> pos[i];
    }

    vector<int> result(n + 1); // 最终数组 A
    SegTree seg(n);            // 创建线段树
    seg.build(1, 1, n);        // 初始化线段树

    // 从后向前插入
    for (int i = n; i >= 1; i--)
    {
        int idx = seg.query(1, 1, n, pos[i]); // 查询第 P_i 个未赋值位置
        result[idx] = i;                      // 在该位置插入 i
        seg.update(1, 1, n, idx);             // 更新该位置为已赋值
    }

    // 输出最终数组
    for (int i = 1; i <= n; i++)
    {
        cout << result[i] << (i < n ? " " : "\n"); // 最后一个数后换行
    }
    return 0;
}
```

