---
title: 刷题日记25-03-05
date: 2025-03-05
categories: [题解,acm]
excerpt: 博主2025-03-05的刷题日记
problems: 
    - id: "37"
      name: "CF170edu_B"
      tags: ["推公式", "打表", "思维"]
    - id: "38"
      name: "CF170edu_C"
      tags: ["排序", "双指针", "黄"]
    - id: "39"
      name: "CF170edu_D"
      tags: ["差分优化", "dp", "绿"]
    - id: "40"
      name: "CF1007div2_B"
      tags: ["构造", "深黄"]
    - id: "41"
      name: "CF1007div2_C"
      tags: ["树", "构造", "思维", "绿"]
    - id: "42"
      name: "CF1007div2_D"
      tags: ["构造", "思维", "递归", "绿"]
---

# 刷题日记25-03-05

# acm 和 cf上分问题

- 保持思考，不要盲目刷题，脱离单调重复、没有提升的状态，不要把抄题解当成学习，区别很大
- 了解和评估当前状态
- 需要学习新算法，还有很多主题
- 接触更多平台，不一定局限于cf



# CF170edu

## CF170edu_B

推公式，打表，思维（1100）

题意：

对于如下公式，给定一个n,k，求对应的c(n,k)

```cpp
for (int n = 0; n < N; n++) {
    C[n][0] = 1;
    C[n][n] = 1;
    for (int k = 1; k < n; k++)
        C[n][k] = C[n][k - 1] + C[n - 1][k - 1];
}
```

思路：

需要推公式，先打表找规律发现公式的数值都是 2 的幂次。

然后发现$C_{n,k}$的数值和n无关，带入发现满足$2^k = 2^{k-1} + 2^{k-1}$

于是直接计算 2 的幂次模MOD的数值即可





## CF170edu_C

排序，双指针（1300，黄）

题意：

有一个n个数字的序列，每次可以取一个数字，第一次可以任取一个数字，但是之后每次取的数字要么和上次相同，要么恰好比上次大 1 ，最多只能取 k 个不同的数字，问最多可以取多少个数字

思路：

简单，排序去重，开桶计数，双指针求连续区间最值

```cpp
//记得如何去重
int n, k;
cin >> n >> k;
vector<int> a(n);
map<int, int> mp;
for (auto &i : a)
    cin >> i, mp[i]++; // 这样写似乎确实快一些
sort(a.begin(), a.end());
auto it = unique(a.begin(), a.end());
a.erase(it, a.end());
int x = a.size();
```



## CF170edu_D

差分优化，dp（1800，绿）

题意：你扮演一个角色，初始“力量”（Strength）和“智力”（Intelligence）属性为 0。游戏中有n个记录，按顺序发生：

- 如果记录 ri=0，获得 1 个属性点，可选择加到力量或智力（总点数M）。
- 如果 ri>0，进行智力检查，要求智力 ≥ri才能通过。
- 如果 ri<0，进行力量检查，要求力量 ≥−ri 才能通过。
   目标是合理分配 M 个属性点，最大化通过的检查次数。

实际上是差分优化dp，定义 dp(i,x)表示前 i个记录，智力值为x时的最大通过次数（因为前i个数字的点数已知，所以可以知道力量点数）

分成三类进行状态转移

````cpp
for (int i = 1; i <= n; i++)
{
    if (a[i] > 0) // 当前这个数字是正数，维护a[i] ~ now的区间
    {
        if (a[i] <= now)
        {
            dif[a[i]]++, dif[now + 1]--;
        }
    }
    else if (a[i] < 0)
    { // 相当于通过和当前可以取到的所有数字的关系把两个前缀和数组合为一体了
        if (now - abs(a[i]) >= 0)
        {
            dif[0]++;
            dif[now + a[i] + 1]--;
        }
    } // 以上维护一段数据的差分数组
    else if(a[i] == 0)
    {
        now++; // 表示当前所有可加的点数
        for (int j = 0; j <= now; j++)
        {
            if (j)
                dif[j] += dif[j - 1];
            dp[j] += dif[j];
        } // 相当于懒惰处理，写回，只有需要修改的时候再修改回差分数组

        for (int j = now; j >= 1; j--)
        {
            dp[j] = max(dp[j], dp[j - 1]);
        } // 因为滚动掉了第一维表示前i个数字的
        // 所以看起来是原地继承，实际上在决策加到哪个数值上
        // 而且注意要反向遍历，恰好不影响
        for (int i = 0; i <= now; i++)
            dif[i] = 0;
        // 不可以clear
    }
}
````



# 1007div2

## CF1007div2_B

构造（深黄）

题意：给定一个正整数 n，要求构造一个长度为 n 的完美排列 p，其中“完美”定义为：对于每个 i（1≤i≤n），前 ii个元素之和 p1+p2+⋯+pi不是完全平方数。如果无法构造，则输出 −1。

思路：

如果 $n(n+1)/2 $是完全平方数，则无论如何排列，i=n时和都是完全平方数，无法满足完美条件。

1. 计算前缀和 sum[i]=a[1]+⋯+a[i]

2. 如果 sum[i]是完全平方数，交换 a[i]和 a[i+1]

3. 交换后，sum[i]变为 sum[i−1]+a[i+1]，打破了完全平方性质



## CF1007div2_C

树，构造，思维（绿）

题意：

在一个意大利村庄中，一只饥饿的老鼠从给定树 $^{\text{∗}}$ 的顶点 $\textrm{st}$ 出发，该树包含 $n$ 个顶点。

给定一个长度为 $n$ 的排列 $p$ ，共有 $n$ 个步骤。在第 $i$ 步时：

- 一块诱人的帕尔马干酪出现在顶点 $p_i$。若老鼠当前位于顶点 $p_i$，它将停留并享用；否则，它将沿简单路径向 $p_i$ 移动一条边。

你的任务是找到这样的排列，使得经过所有 $n$ 步后，老鼠必定到达陷阱所在的顶点 $\textrm{en}$。

注意：老鼠必须在完成所有 $n$ 步后到达 $\textrm{en}$，但在过程中可能提前经过 $\textrm{en}$。

思路：

1. 首先要意识到，当前所在的**具体节点位置无需考虑**，因为只需要满足序列最后输出的是$en$结点即可
2. 然后发现其实就是先把en视为树根，然后每次取一个小的子树区域，一直缩小，可以视为删除叶子结点

3. 于是有一种构造方法：先处理出以en为根节点的深度，从大到小排序，每次输出一个结点，最后输出en即可



## CF1007div2_D

构造，思维，递归（绿）

题意：

这是该问题的简单版本，此版本中 $l = r$。给定一个正整数 $n$ 和一个无限二进制序列 $a$ 的前 $n$ 项，该序列定义如下：

- 对于 $m > n$，$a_m = a_1 \oplus a_2 \oplus \ldots \oplus a_{\lfloor \frac{m}{2} \rfloor}$ $^{\text{∗}}$。

你的任务是计算给定区间 $[l, r]$ 内元素的和：$a_l + a_{l + 1} + \ldots + a_r$。

思路：

- 需要注意到，如果m为偶数，递归之后相邻两个数字的异或和=0，可以抵消，利用这点递归求解

- 预处理出异或前缀和，直接查询即可

- 需要熟悉异或性质

```cpp
function<int(int)> dfs = [&](int x)
{
    if (x <= n) return get_xor(a, x, x); // 也就是本身
    if (x / 2 <= n) return get_xor(a, 1, x / 2);
    int ans = get_xor(a, 1, n);
    if ((x / 2) % 2 == 0) ans ^= dfs(x / 2); // 如果一半是奇数，已经抵消，但如果是偶数，就要计算
    if (n % 2 == 0) ans ^= dfs(n + 1); // 如果是奇数，已经抵消，只用算一次，不用递归
    return ans;
};
```

