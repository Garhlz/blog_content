---
title: 刷题日记25-03-07
date: 2025-03-07
categories: [题解,acm]
excerpt: 博主2025-03-07的刷题日记
problems: 
    - id: "16"
      name: "CF175edu_C"
      tags: ["二分答案", "1500", "黄"]
    - id: "17"
      name: "CF175edu_D"
      tags: ["树形dp", "1600", "绿"]
    - id: "18"
      name: "CF1006div3_C"
      tags: ["位运算", "mex", "构造", "1200", "黄"]
    - id: "19"
      name: "CF1006div3_D"
      tags: ["逆序对", "dp", "1300", "黄"]
    - id: "20"
      name: "CF1006div3_E"
      tags: ["构造", "递归", "1500", "黄"]
    - id: "21"
      name: "CF1006div3_F"
      tags: ["排列组合", "位运算", "异或", "数论", "1700", "绿"]
    - id: "22"
      name: "CF174edu_B"
      tags: ["贪心", "1200", "深黄"]
    - id: "23"
      name: "CF174edu_C"
      tags: ["dp", "1500", "黄"]
    - id: "24"
      name: "CF174edu_D"
      tags: ["字符串", "回文串", "二分答案", "1800", "绿"]
    - id: "25"
      name: "CF1005div2_B"
      tags: ["双指针", "1100", "深黄"]
    - id: "26"
      name: "CF1005div2_D"
      tags: ["dp", "位运算", "异或", "1900", "绿"]
---

# 刷题日记25-03-07

今天我准备先复习之前写过的cf场，把题目的解题思路和收获写下来，包括核心代码。然后再写一些新题或者abc

复习了最近的四场：edu175 174,1006div3,1005div2，配合ai写了一些题解s![image-20250307154743403](/images/image-20250307154743403.png)

主要涉及的题型：构造，贪心，二分答案，dp，位运算

# 175edu

## CF175edu_C

一维序列涂色，二分答案（1500，黄）

题意：给定一个长度为 n 的条带，初始所有单元格为红色。你可以进行最多 k 次操作，每次选择一段连续单元格涂成蓝色（可以覆盖已涂蓝色的单元格，但不能涂成红色）。每个单元格有：

- 期望颜色（红色 'R' 或蓝色 'B'）。
- 惩罚值 ai（若最终颜色错误，则计入惩罚）。
- 目标是使最终涂色的**总惩罚值**最小，其中总惩罚值定义为所有错误颜色单元格的惩罚值中的**最大值**（若无错误，则为 0）。

看到所有值的最大值的最小值，想到二分答案。

二分当前的惩罚值。check函数是贪心涂一段序列，如果当前格子的惩罚值大于x，则必须要涂色，或者必须不涂色。因为是涂一个连续段，所以用一个变量表示当前是否在涂色。如果当前惩罚值小于x，则不涂色。

如下是ai优化过的check函数

```cpp
// 检查是否能在 k 次操作内使所有错误惩罚值 <= x
bool canAchieve(int x, const vector<int>& penalties, const string& target, int n, int k) {
    int painting = 0; // 是否正在涂蓝色段（1 表示是）
    int ops = k;      // 剩余操作次数
    for (int i = 0; i < n; i++) {
        if (penalties[i + 1] > x) { // 惩罚值 > x，必须涂正确颜色
            if (target[i] == 'B') { // 期望蓝色
                if (!painting) {    // 未在涂色，新开一段
                    painting = 1;
                    ops--;
                }
            } else {                // 期望红色
                if (painting) {     // 正在涂蓝，结束此段
                    painting = 0;
                }
            }
        }
        if (ops < 0) return false; // 操作次数不足
    }
    return true;
}
```



## CF175edu_D

简单树形dp（1600，绿）

题意：给定一棵有根树，根为顶点 1，包含 n个顶点。定义 dx为根到顶点 x   的距离（边数）。初始棋子在根节点，可执行以下操作任意次：

- 从当前顶点v 移动到u ，满足 du=dv+1 。
  - 若 v 是根（顶点 1），u可以是任意子节点。
  - 若 v 不是根，u不能是 v 的邻居（无直接边）。 目标是计算**有效顶点序列**的数量，即存在一种移动方式使棋子按顺序访问序列中所有顶点的方案数，结果对 998244353 取模。

树形dp。令dpi = 以当前结点结尾的访问序列方案数，可以由上一层所有结点的方案数之和 - 父节点的方案数得到。因此需要记录每一层的方案数，dfs/bfs转移即可(这里是bfs)。注意负数取模要先加上MOD

```cpp
q.push(1);
while (!q.empty()) {
    int x = q.front();
    q.pop();
    for (int y : adj[x]) {
        if (x == 1) {
            dp[y] = 1; // 根的子节点直接可达
        } else {
            // 子节点 y 的序列数 = 上一层总和 - dp[x]
            dp[y] = (layer_sum[depth[y] - 1] - dp[x] + MOD) % MOD;
        }
        layer_sum[depth[y]] = (layer_sum[depth[y]] + dp[y]) % MOD;
        q.push(y);
    }
}
```



# 1006div3

## CF1006div3_C

位运算，mex，构造题(1200，黄)

给定长度n和目标值x，构造一个数组，长度为n，所有数的按位或之和=x，并且最大化数组的MEX

**按位或与 x**：

- x 的二进制表示决定数组元素的最小要求。
- 若 x 的某位为 1，至少一个 ai的该位为 1。

**关键观察**：

- xx的最低 0 位（从右起第一个 0 的位置，记为 t）决定了最大 MEX。
- 若 x=7=(111)2，最低 0 位是第 3 位（从 0 开始计数），MEX=8
- 数组需包含 0,1,2,…,2^t−1, MEX 为 2^t。

**构造策略**：

- n=1：直接输出 x。

- n<2^t：填充 0,1,…,n−2,最后补 x。

- n=2^t：正好填 0,1,…,n−1。

- n>2^t：填 0,1,…,2^t-1。剩余全部填 x。

  

## CF1006div3_D

逆序对，简单dp（1300，黄）

题意：给定一个长度为n的数组a。Akito 需要使用恰好一次咒语（对子数组(l,r)进行向左循环移位），使操作后的数组逆序对数量最小化。

n^2可以接受。dp(i,j)是在区间内移位减少的逆序对数。状态转移方程如下：

```cpp
dp[i][j] = dp[i][j-1] + (a[j] < a[i]?1:(a[j] > a[i]?-1:0));
```



## CF1006div3_E

构造题，构造二维坐标点集，贪心，用递归分解（1500，黄）

题意：在笛卡尔坐标系中放置n个点，0<=n<=500,使其中恰好有k对点满足之间的欧几里得距离=曼哈顿距离。构造任意一对点的坐标。

- 欧几里得距离=曼哈顿距离，相当于两个点的横坐标或者纵坐标相等。

- 而同一行或者同一列的x个点可以贡献x*(x-1)/2个点对（组合数）
- 用类似二进制拆分的贪心策略，将k分解为若干行的点对数之和，每行 x个点贡献x*(x-1)/2。先找最大 x 满足 x(x−1)/2≤k，剩余 k−x(x−1)/2递归处理（占据下一行，横坐标也相应偏移）

核心代码如下

```cpp
vector<pii> constructPoints(int k, int x_start = 0, int y_start = 0) {
    if (k == 0) {
        return {};
    }
    // 找到最大 x，使得 x*(x-1)/2 <= k
    int x = 0;
    while (x * (x - 1) / 2 <= k) {
        x++;
    }
    x--; // 回退到满足条件的最大值
    int pairs = x * (x - 1) / 2; // 当前行贡献的对数

    // 递归处理剩余的 k - pairs
    vector<pii> next = constructPoints(k - pairs, x_start + x + 1, y_start + 1);
    
    // 当前行放置 x 个点
    vector<pii> current;
    for (int i = 0; i < x; i++) {
        current.emplace_back(x_start + i, y_start);
    }
    current.insert(current.end(), next.begin(), next.end());
    return current;
}
```



## CF1006div3_F

排列组合，位运算，异或，数论（1700，绿）

现在对我来说很艰难。

给出一个异或杨辉三角的生成公式，给出第一行的k，要求输出第n行的内容

公式如下：
$$
T_{i,j} = 
\begin{cases} 
T_{i-1,j-1} \oplus T_{i-1,j}, & \text{if } 1 < j < i \\ 
T_{i-1,j}, & \text{if } j = 1 \\ 
T_{i-1,j-1}, & \text{if } j = i 
\end{cases}
$$

- 通过观察，发现 $Tn,j $与组合数 $\binom{n-1}{j-1}$ 的奇偶性相关：
- 当$\binom{n-1}{j-1}$ 为奇数时：$ T_{n,j} = k$
- 当$\binom{n-1}{j-1}$ 为偶数时：$ T_{n,j} = 0$

代码使用条件 (j−1)&(n−1)==j−1 判断奇偶性，这来源于卢卡斯定理

![image-20250307113615959](/images/image-20250307113615959.png)

```cpp
void solve() {
    int n, k;
    cin >> n >> k;
    int mask = n - 1; // 用于检查 j-1 的二进制位是否为 n-1 的子集

    // 直接输出第 n 行元素，避免额外的 vector 存储
    for (int j = 1; j <= n; j++) {
        int pos = j - 1; // 对应组合数 C(n-1, j-1) 的下标
        cout << ((pos & mask) == pos ? k : 0); // 判断奇偶性并输出 k 或 0
        cout << (j < n ? " " : "\n"); // 最后一个元素后换行，其余空格
    }
}
```



# 174edu

## CF174edu_B

涂色题，贪心（1200，深黄）

给定一个 n×m 的表格，初始时第 i行第 j 列的颜色为$a_{i,j}$  。

- **陌生人（strangers）**：两个单元格不共享边（即不相邻，仅允许角落接触）。
- **陌生人集合**：集合中任意两单元格都不相邻（包含 0 或 1 个单元格的集合也算）。
- **操作**：选择一个颜色相同的陌生人集合，将其涂成任意颜色。 目标：将整个表格涂成单一颜色，求最少操作次数。

对于任意一个颜色的集合，如果有相邻格子，总可以找到一种方式用两次将它们改变颜色(类似象棋棋盘)。如果没有相邻格子，则只需要一次操作。由此贪心即可



## CF174edu_C

DP，三个状态之间的转移（1500，黄）

题意：给定一个长度为 n 的整数数组 a，其中每个元素$a_i \in \{1, 2, 3\}$。求数组中“美丽子序列”的数量，结果对998244353取模。

- 美丽子序列定义
  - 长度至少为 3。
  - 除第一个元素外，每个元素左侧有比它小的元素。
  - 除最后一个元素外，每个元素右侧有比它大的元素。

因此根据定义，可能的序列只能是1222....2223，根据这种限制状态转移，最后取以3结尾的序列数量

DP(i,x)表示前i个数字，以x结尾的序列数量

x=1,当前只有1个序列，即它自身

x=2，可以从之前所有以2结尾的序列继承得到，也可以由之前所有以1结尾的序列继承得到

x=3，由2结尾的序列继承得到

第一维i可以舍弃，因为都是继承之前的和，而不是某个单个位置的值。

思路其实很简单，以下是dp代码

```cpp
vector<int> dp(4, 0);
dp[0] = 1;
while (n--)
{
    int x;
    cin >> x;
    if (x == 2)
        dp[x] = (dp[x] + dp[x]) % MOD;
    dp[x] = (dp[x] + dp[x - 1]) % MOD; // 注意顺序
}
cout << dp[3] << '\n';
```





## CF174edu_D

字符串处理，回文串，二分答案（1800，绿）

题意：给定一个由小写拉丁字母组成的字符串 s。

- **操作**：选择一个连续子串（可为空），对其字符进行任意重排，最多操作一次。
- **目标**：将 s 变成回文串，求操作子串的最小长度。

首先去除两端的相同字母。对于剩余字符串，因为是重排连续序列使之成为回文串，一定需要从头或者从尾开始重排。因此假设从头开始重排，二分出最近的右端点即可，然后反转字符串再进行一遍相同操作。

接下来是check()函数，经过ai的优化比较清晰了

```cpp
// 检查前缀 [0, p] 是否可行
bool check(const string& s, int p, const vector<int>& total) {
    int n = s.size();
    // 检查 p 外的匹配
    for (int i = p + 1; i < n; i++) {
        if (n - 1 - i > p && s[i] != s[n - 1 - i]) {
            return false; // 不可调整的非回文对
        }
    }
    // 统计需求量
    vector<int> need(26, 0);
    for (int i = 0; i <= p; i++) {
        int j = n - 1 - i;
        if (j > p) {
            need[s[j] - 'a']++; // 需要在 [0, p] 中提供 s[j]
        }
    }
    // 检查是否每种字符的可用量足够
    for (int c = 0; c < 26; c++) {
        if (need[c] > total[c] / 2) { // 回文需两侧匹配
            return false;
        }
    }
    return true;
}
```

- 当前要重排的长度之外的字符，如果对称位置不满足回文性质，则不可
- 当前要重排的序列之内的字符如果和对称位置不同，则计算入need数组，最后和这段序列的所有字母数量相比较，如果need[c] > total[c] / 2，则表示不可

关键是需要根据回文串的性质想到二分答案。然后check()函数不太好想



# 1005div2

## CF1005div2_B

双指针（1100，深黄）

关键是要理解题意

题意：

给定一个数组 a，可以最多一次移除一个非空连续子数组，目标是使操作后数组的分数最大。

- **分数定义**：数组长度减去不同元素的数量。
- **操作**：选择 $l \leq r \leq n$，移除子数组$ [a_l, a_{l+1}, \ldots, a_r]$。
- **要求**:
  1. 分数最大。
  2. 若分数相同，选择操作后数组长度最短的解。
  3. 若仍有多解，输出任意一解。

因此有：

- 如果删除一个只出现过一次的数字，长度减少，不同元素数量也减少，分数不变；但是如果删除出现多次的数字，分数就会减少

- 找到一段最长的连续序列，其中每个数字只出现过一次

- 用双指针

  如下是ai写的一段双指针，非常规范

  ```cpp
  for (int i = 0; i < n; i++) {
      if (mp[a[i]] == 1) { // 表示出现的数量
          int len = 1;
          while (i + len < n && mp[a[i + len]] == 1) {
              len++;
          }
          if (len > maxlen) {
              maxlen = len;
              ansl = i + 1; // 1-based 索引, 这里只记录左端点
          }
          i = i + len - 1; // 跳到段末
      }
  }
  ```



## CF1005div2_C

简单DP，贪心（1300，深黄）

给定一个长度为n 的数组a，元素为非零整数。初始有 0 枚硬币，重复以下操作直到数组为空：

- 设当前数组大小为m。
- 选择一个位置 i (1≤i≤m )
  - 获得 $|a_i|$枚硬币。
  - 若$a_i < 0$，删除从$a_i$开始的后缀（保留 $[a_1, \ldots, a_{i-1}]$）。
  - 若$a_i > 0$，删除以$a_i$结尾的前缀（保留$[a_{i+1}, \ldots, a_m]$）

- 目标：计算最终能获得的最大硬币数量。

贪心地考虑，一定是从从前到后取正的ai,从后往前取负数，直到两头碰在一起。于是想到，做一个只有正数的前缀和和只有负数绝对值的后缀和，枚举最大的pre[i] + suf[i]即可



## CF1005div2_D

DP，位运算，前缀异或和（1900，绿）

题意：

给定一个长度为n的数组 w，表示n个史莱姆的体重。第i个史莱姆可以吃掉第j个史莱姆当且仅当$w_i \geq w_j$。吃掉后，$w_i = w_i \oplus w_j$，$w_j$消失。现给出操作如下：

- 在数组末尾添加一个体重为x的史莱姆。
- 新史莱姆从右向左尝试吃左侧相邻史莱姆，若无法吃则停止。
- 得分为被吃掉的史莱姆数。 有 q次询问，每次给定体重x，求每次的实验得分（每次都不是真的吃掉）

分析思路：

- 涉及到异或以及比大小，我们先想数字的二进制性质。对一个数字的大小有决定性影响的是它的最高有效位（msb），如果a > b,有msb(a) >= msb(b)。如果msb(a) == msb(b)，a和b异或之后，a的msb将变为0（异或的性质）。

- 所以，我们可以预处理出对于每一个以i结尾的前缀序列，最右侧的第一个msb>=j的数字的位置，形成dp数组。而x到第一个最高有效位大于等于它的数字之前的所有数字ai都一定有 x > ai。这就可以简化处理查询的速度，每个查询从线性时间到只需要x的位数的时间，也就是常数时间。
- 跳到最高有效位之后，x和中间序列的异或和异或，之后再和目标数字比较，如果x>=目标数字，可以继续循环，否则结束循环。

预处理：

```cpp
const int W = 30;
vector<vector<int>> pre(n + 1, vector<int>(W + 1, 0));
for (int i = 1; i <= n; i++)
{
    int msb = __lg(w[i]); // 最高有效位
    for (int j = 0; j <= msb; j++)
    {
        pre[i][j] = i; // 比当前msb小或相等的最高有效位数字的最近跳转位置都是当前位置
    }
    for (int j = msb + 1; j <= W; j++)
    {
        pre[i][j] = pre[i - 1][j]; // 否则直接继承
    }
}
```

核心循环：

```cpp
while (q--)
{
    int x;
    cin >> x;
    int now = n; // 当前位置
    for (int j = W; j >= 0; j--)
    {
        if (x < (1LL << j))
            continue;          // x 不足以吃这一位
        int nxt = pre[now][j]; // 左侧最近 w_k >= 2^j， 不能直接吃掉
        x ^= s[now] ^ s[nxt];  // 吃掉 (nxt, now]
        now = nxt;
        if (now == 0 || w[now] > x)
            break;   // 吃不动或结束
        x ^= w[now]; // 吃掉 w[now]
        now--;
    }
    cout << n - now << ' ';
}
```

其实可以理解为把x可以吃掉的所有位数进行了二进制拆分，然后贪心跳转，通过异或前缀和处理序列数据。还是需要加深对于二进制转换和位运算的理解才行。
